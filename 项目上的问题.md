- 你在项目上遇到过哪些难题？
- 在项目中哪里用到用到了redis，mq？
- 项目介绍：我们这个项目是华为2012部门的门户网站，它主要是提供给科学家们进行一个技术交流发布难题的平台。整改项目组采用的spring boot框架加上mybatis+mysql,中间件用的是redis。
   - 项目是做什么的？
   - 项目的价值(解决了什么问题，带来了什么价值)？
   - 明确的功能
   - 明确的技术
   - 个人在项目中的位置和作用
   - 项目的亮点
   - 明确项目的架构
   - 
- 门户网站的权限架构？
- 绿坝审核对接第三方接口时的加密？
- 你在项目上遇到过什么难题？
- 你在项目上有哪些亮点？
  - 引入分布式锁解决并发问题：
    - 背景：当时有一个场景会出现并发问题，就是已消费的资源在当天内如果没有使用就会被自动取消，以及用户也可以主动取消。这两个操作有时候就会出现并发问题，重复发送给下游软件，导致下游处理失败。为了解决该问题，我采用了分布式去解决。
    - 技术选型：其实分布式锁有很多种解决方案，比如基于数据库、zookeeper和redis。
      - 基于数据库的实现是最简单的，在数据库中新建一张表，然后加锁时往里面添加一条记录，释放锁时将记录删除，通过唯一性约束来避免记录的重复，当要加锁时，判断数据库中是否有这条记录，没有则插入一条。优点是实现简单，缺点是太依赖数据库，并且在高并发的情况下对数据库造成压力，并且性能也不好。基于数据库的悲观锁当然也可以实现，但是由于悲观锁的机制，容易导致锁表，也会导致线程阻塞的问题。
      - 所以最终选择了用redis实现，在redis中我们刚开始使用了setnx的方案，但是后来还是会经常出现并发的问题，后来经过检查才发现，我们设置的解锁的超时时间过短，导致锁提前释放掉了，但是拉长时间又会导致接口的吞吐量降低，最后我们发现redisson中有实现看门狗的机制，可以自动帮我们做续期，所以我们选了redis。
  - 
- 
- 2025-03-20综合面试：
 - 数据库的三大范式？在实际应用中有没有违反三大范式的情况
 - 有没有使用过MQ？具体是在哪里使用的？
   - 在检测需求软件中，我用到了MQ，下游软件通过RabbitMQ将百万级别的数据批量发送到指定Exchange中，我通过监听队列消费拉取数据，然后将缓存数据分批次写入数据库，我这里使用的容错机制是死信队列
   - 死信队列：用来存储失败的消息
 - 有没有使用过多线程？具体代码是怎么写的
   - 用过，在检测需求软件中，使用在我发送数据时，一个线程去发送数据，另一个线程去给状态检测软件上报状态。
   - 实现代码的方式是通过线程池的方式去创建的：ExecutorService executorService = Executors.newFixedThreadPool(5);创建一个固定大小的线程池，这里如果有其他业务需求的话还可以使用不同的线程池，比如创建一个带缓存的线程池(newCacheThreadPool),带定时任务的(newScheduleThreadPool)，单线程的线程池（newSingleThreadPool）
   - 配置文件中的参数：
     - acknowledge-mode: manual  手动ACK确认
     - prefetch: 1000   单次拉取消息数（控制吞吐）
     - concurrency      最小线程数
     - max-concurrency  最大线程数
- redis问题：
  - redis的双写一致性问题：
  - redis的分布式锁：
  - redis的过期策略：
    - 延迟双删：
      - 实现步骤：
        - 先删缓存：避免读到旧数据
        - 再更新数据库
        - 延迟再删缓存(一般延迟时间是1秒)
      - 使用场景：对一致性要求不高，允许短暂的延迟
      - 优点：容易实现，覆盖多数并发场景
      - 缺点：延迟时间难以确认，没办法避免极端并发下的一致性
    - 基于数据库binlog的同步(canal)：
      - 使用场景：异构系统同步，对一致性要求高
      - 实现步骤：
        - 数据库开启Binlog
        - 通过canal监听Binlog的变更
        - 将变更事件同步到reids
      - 架构图：MySQL → Binlog → Canal Server → MQ → Redis消费者 → 更新缓存
      - 优点：无入侵式代码，且支持多数据源同步
      - 缺点：架构复杂，维护成本高，同步延迟依赖canal的处理速度
    - 读写锁：
      - 实现:利用redisson的读写锁
        - 共享锁：读锁readLock,加锁后可以和其他线程共享读操作
        - 排他锁：也叫独占锁，加锁后阻塞其他所有线程的读写操作
      - 优点：能保证数据的强一致性
      - 缺点：性能不行
    - 基于消息队列的最终一致性：
      - 场景：允许短暂不一致，但最终一致性
      - 步骤：
        - 更新数据库
        - 发送消息到MQ，通知缓存更新
        - 消费者异步消费更新缓存
      - 优点：解耦数据库与缓存操作，高可用。
      - 缺点：存在延迟，需处理消息丢失或重复消费问题。
    - 
  - redis的持久化问题：
  - redis的过期策略：
    - 过期键的删除：
      - 定期删除：每隔一段时间便随即抽查设置了过期时间的键，查看是否过期，过期则删除。默认每100ms查询一次，也可以设置
        - 优点：平衡内存清理和性能消耗
        - 缺点：可能会删除不完过期的键，有残留
      - 懒惰删除：当客户访问一个键时redis会先查看它是否过期，如果过期就删除
        - 优点：仅再访问时触发，没有其他的性能开销
        - 缺点：若某些键一直没有被访问，那它们会一直占用内存，导致内存泄漏。
      - 
    - 内存淘汰策略：当 Redis 内存达到 maxmemory 限制时，触发内存淘汰机制，根据配置的策略删除键以释放空间。
      - noeviction(默认)：拒绝写入，直接返回错误，允许读取。
      - allkeys-lru：淘汰最近最少使用的键
      - volatile-lru：淘汰最近最少使用的键，但是仅仅是针对设置了过期时间的
      - allkeys-lfu：淘汰最不经常使用的键
      - volatile-lfU：淘汰最近最不经常使用的，但是仅仅是针对设置了过期时间的
      - allkeys-random：随即淘汰
      - volatile-random：随机淘汰过期时间的键
      - volatile-ttl：淘汰 剩余存活时间最短（TTL） 的键。
    - 最佳实践
      - 缓存场景：优先使用 allkeys-lru 或 allkeys-lfu，保留高频访问数据
      - 混合读写场景：若部分数据需持久化，使用 volatile-lru 或 volatile-ttl
      - 严格数据保护：选择 noeviction，但需监控内存使用，及时扩容。
  - redis的高可用问题：
  - reids的持久化问题：
     - RDB：redisDataBase
       - 工作原理：
       - 优点：
       - 缺点：
     - AOF：Append-only file
       - 工作原理：
       - 优点：
       - 缺点
     - 
  - redis的其他问题
- 
